{"version":3,"sources":["../node_modules/bnc-onboard/dist/esm/hd-wallet-51018814.js"],"names":["publicToAddress","ethUtil","toChecksumAddress","generateAddresses","account","offset","publicKey","chainCode","path","hdk","HDKey","Buffer","addresses","i","dkey","deriveChild","address","toString","push","dPath","concat","isValidPath","parts","split","includes","undefined","accountFieldNumber","Number","slice","isNaN","changeFieldNumber","addressFieldNumber"],"mappings":"mGAAA,2IAGIA,EAAkBC,kBAClBC,EAAoBD,oBAGxB,SAASE,EAAkBC,EAASC,GAClC,IAAIC,EAAYF,EAAQE,UACpBC,EAAYH,EAAQG,UACpBC,EAAOJ,EAAQI,KACfC,EAAM,IAAIC,IACdD,EAAIH,UAAY,IAAIK,SAAOL,EAAW,OACtCG,EAAIF,UAAY,IAAII,SAAOJ,EAAW,OAGtC,IAFA,IAAIK,EAAY,GAEPC,EAAIR,EAAQQ,EAXL,EAWuBR,EAAQQ,IAAK,CAClD,IAAIC,EAAOL,EAAIM,YAAYF,GACvBG,EAAUhB,EAAgBc,EAAKR,WAAW,GAAMW,SAAS,OAC7DL,EAAUM,KAAK,CACbC,MAAO,GAAGC,OAAOZ,EAAM,KAAKY,OAAOP,GACnCG,QAASd,EAAkB,KAAKkB,OAAOJ,MAI3C,OAAOJ,EAGT,SAASS,EAAYb,GACnB,IAAIc,EAAQd,EAAKe,MAAM,KAEvB,GAAiB,MAAbD,EAAM,GACR,OAAO,EAGT,GAAiB,QAAbA,EAAM,GACR,OAAO,EAGT,IAAK,CAAC,MAAO,KAAM,SAAU,QAAQE,SAASF,EAAM,IAClD,OAAO,EAGT,QAAiBG,IAAbH,EAAM,IAAiC,OAAbA,EAAM,GAClC,OAAO,EAGT,IAAII,EAAqBC,OAAOL,EAAM,GAAGM,MAAM,GAAI,IAEnD,GAAIC,MAAMH,IAAuBA,EAAqB,GAA4B,MAAvBJ,EAAM,GAAGM,OAAO,GACzE,OAAO,EAGT,QAAiBH,IAAbH,EAAM,GACR,OAAO,EAGT,IAAIQ,EAAoBH,OAAOL,EAAM,IAErC,GAAIO,MAAMC,IAAsBA,EAAoB,EAClD,OAAO,EAGT,QAAiBL,IAAbH,EAAM,GACR,OAAO,EAGT,IAAIS,EAAqBJ,OAAOL,EAAM,IAEtC,QAAIO,MAAME,IAAuBA,EAAqB","file":"static/js/69.84f5db00.chunk.js","sourcesContent":["import * as ethUtil from 'ethereumjs-util';\nimport HDKey from 'hdkey';\nimport { Buffer } from 'buffer';\nvar publicToAddress = ethUtil.publicToAddress,\n    toChecksumAddress = ethUtil.toChecksumAddress;\nvar numberToGet = 5;\n\nfunction generateAddresses(account, offset) {\n  var publicKey = account.publicKey,\n      chainCode = account.chainCode,\n      path = account.path;\n  var hdk = new HDKey();\n  hdk.publicKey = new Buffer(publicKey, 'hex');\n  hdk.chainCode = new Buffer(chainCode, 'hex');\n  var addresses = [];\n\n  for (var i = offset; i < numberToGet + offset; i++) {\n    var dkey = hdk.deriveChild(i);\n    var address = publicToAddress(dkey.publicKey, true).toString('hex');\n    addresses.push({\n      dPath: \"\".concat(path, \"/\").concat(i),\n      address: toChecksumAddress(\"0x\".concat(address))\n    });\n  }\n\n  return addresses;\n}\n\nfunction isValidPath(path) {\n  var parts = path.split('/');\n\n  if (parts[0] !== 'm') {\n    return false;\n  }\n\n  if (parts[1] !== \"44'\") {\n    return false;\n  }\n\n  if (![\"60'\", \"1'\", \"73799'\", \"246'\"].includes(parts[2])) {\n    return false;\n  }\n\n  if (parts[3] === undefined || parts[3] === \"0'\") {\n    return true;\n  }\n\n  var accountFieldNumber = Number(parts[3].slice(0, -1));\n\n  if (isNaN(accountFieldNumber) || accountFieldNumber < 0 || parts[3].slice(-1) !== \"'\") {\n    return false;\n  }\n\n  if (parts[4] === undefined) {\n    return true;\n  }\n\n  var changeFieldNumber = Number(parts[4]);\n\n  if (isNaN(changeFieldNumber) || changeFieldNumber < 0) {\n    return false;\n  }\n\n  if (parts[5] === undefined) {\n    return true;\n  }\n\n  var addressFieldNumber = Number(parts[5]);\n\n  if (isNaN(addressFieldNumber) || addressFieldNumber < 0) {\n    return false;\n  }\n\n  return true;\n}\n\nexport { generateAddresses, isValidPath };"],"sourceRoot":""}