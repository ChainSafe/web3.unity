{"version":3,"sources":["../../src/Eth.js","../../src/utils.js","../node_modules/@ledgerhq/errors/dist/index.js"],"names":["starkQuantizationTypeMap","eth","erc20","erc721","erc20mintable","erc721mintable","hexBuffer","str","Buffer","maybeHexBuffer","constructor","scrambleKey","transport","this","getAddress","paths","splitPath","buffer","boolDisplay","boolChaincode","response","result","publicKeyLength","addressLength","provideERC20TokenInformation","data","send","then","e","signTransaction","offset","rawTx","toSend","rlpTx","decode","rlpOffset","chainIdPrefix","rlpVrs","encode","chainIdSrc","chainIdBuf","maxChunkSize","chunkSize","i","apduResponse","v","r","s","remapTransactionRelatedErrors","getAppConfiguration","signPersonalMessage","message","signEIP712HashedMessage","domainSeparator","hashStruct","starkGetPublicKey","starkSignOrder","sourceTokenAddressHex","destinationTokenAddressHex","sourceQuantization","destinationQuantization","amountSell","amountBuy","starkSignOrder_v2","sourceQuantizationType","Error","destinationQuantizationType","sourceMintableBlobOrTokenId","destinationMintableBlobOrTokenId","starkSignTransfer","transferTokenAddressHex","targetPublicKeyHex","transferQuantization","amountTransfer","starkSignTransfer_v2","conditionalTransferAddressHex","transferQuantizationType","transferMintableBlobOrTokenId","conditionalTransferFact","starkProvideQuantum","operationContractHex","operationQuantization","starkProvideQuantum_v2","operationQuantizationType","operationMintableBlobOrTokenId","starkUnsafeSign","hashHex","eth2GetPublicKey","eth2SetWithdrawalIndex","path","components","element","number","parseInt","isNaN","foreach","index","array","callback","res","iterate","Promise","arr","errorClasses","deserializers","addCustomErrorDeserializer","name","deserializer","createCustomErrorClass","C","fields","Object","assign","stack","prototype","EthAppPleaseEnableContractData","TransportRaceCondition","TransportError","id","StatusCodes","PIN_REMAINING_ATTEMPTS","INCORRECT_LENGTH","MISSING_CRITICAL_PARAMETER","COMMAND_INCOMPATIBLE_FILE_STRUCTURE","SECURITY_STATUS_NOT_SATISFIED","CONDITIONS_OF_USE_NOT_SATISFIED","INCORRECT_DATA","NOT_ENOUGH_MEMORY_SPACE","REFERENCED_DATA_NOT_FOUND","FILE_ALREADY_EXISTS","INCORRECT_P1_P2","INS_NOT_SUPPORTED","CLA_NOT_SUPPORTED","TECHNICAL_PROBLEM","OK","MEMORY_PROBLEM","NO_EF_SELECTED","INVALID_OFFSET","FILE_NOT_FOUND","INCONSISTENT_FILE","ALGORITHM_NOT_SUPPORTED","INVALID_KCV","CODE_NOT_INITIALIZED","ACCESS_CONDITION_NOT_FULFILLED","CONTRADICTION_SECRET_CODE_STATUS","CONTRADICTION_INVALIDATION","CODE_BLOCKED","MAX_VALUE_REACHED","GP_AUTH_FAILED","LICENSING","HALTED","TransportStatusError","statusCode","statusText","keys","find","k","smsg","code","getAltStatusMessage","statusCodeStr","toString"],"mappings":"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","file":"static/js/24.2d0db0fe.chunk.js","sourcesContent":["/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//@flow\n\n// FIXME drop:\nimport { splitPath, foreach } from \"./utils\";\nimport { EthAppPleaseEnableContractData } from \"@ledgerhq/errors\";\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport { BigNumber } from \"bignumber.js\";\nimport { encode, decode } from \"rlp\";\n\nexport type StarkQuantizationType =\n  | \"eth\"\n  | \"erc20\"\n  | \"erc721\"\n  | \"erc20mintable\"\n  | \"erc721mintable\";\n\nconst starkQuantizationTypeMap = {\n  eth: 1,\n  erc20: 2,\n  erc721: 3,\n  erc20mintable: 4,\n  erc721mintable: 5,\n};\n\nfunction hexBuffer(str: string): Buffer {\n  return Buffer.from(str.startsWith(\"0x\") ? str.slice(2) : str, \"hex\");\n}\n\nfunction maybeHexBuffer(str: ?string): ?Buffer {\n  if (!str) return null;\n  return hexBuffer(str);\n}\n\nconst remapTransactionRelatedErrors = (e) => {\n  if (e && e.statusCode === 0x6a80) {\n    return new EthAppPleaseEnableContractData(\n      \"Please enable Contract data on the Ethereum app Settings\"\n    );\n  }\n  return e;\n};\n\n/**\n * Ethereum API\n *\n * @example\n * import Eth from \"@ledgerhq/hw-app-eth\";\n * const eth = new Eth(transport)\n */\nexport default class Eth {\n  transport: Transport<*>;\n\n  constructor(transport: Transport<*>, scrambleKey: string = \"w0w\") {\n    this.transport = transport;\n    transport.decorateAppAPIMethods(\n      this,\n      [\n        \"getAddress\",\n        \"provideERC20TokenInformation\",\n        \"signTransaction\",\n        \"signPersonalMessage\",\n        \"getAppConfiguration\",\n        \"signEIP712HashedMessage\",\n        \"starkGetPublicKey\",\n        \"starkSignOrder\",\n        \"starkSignOrder_v2\",\n        \"starkSignTransfer\",\n        \"starkSignTransfer_v2\",\n        \"starkProvideQuantum\",\n        \"starkProvideQuantum_v2\",\n        \"starkUnsafeSign\",\n        \"eth2GetPublicKey\",\n        \"eth2SetWithdrawalIndex\",\n      ],\n      scrambleKey\n    );\n  }\n\n  /**\n   * get Ethereum address for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @option boolChaincode optionally enable or not the chaincode request\n   * @return an object with a publicKey, address and (optionally) chainCode\n   * @example\n   * eth.getAddress(\"44'/60'/0'/0/0\").then(o => o.address)\n   */\n  getAddress(\n    path: string,\n    boolDisplay?: boolean,\n    boolChaincode?: boolean\n  ): Promise<{\n    publicKey: string,\n    address: string,\n    chainCode?: string,\n  }> {\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport\n      .send(\n        0xe0,\n        0x02,\n        boolDisplay ? 0x01 : 0x00,\n        boolChaincode ? 0x01 : 0x00,\n        buffer\n      )\n      .then((response) => {\n        let result = {};\n        let publicKeyLength = response[0];\n        let addressLength = response[1 + publicKeyLength];\n        result.publicKey = response\n          .slice(1, 1 + publicKeyLength)\n          .toString(\"hex\");\n        result.address =\n          \"0x\" +\n          response\n            .slice(\n              1 + publicKeyLength + 1,\n              1 + publicKeyLength + 1 + addressLength\n            )\n            .toString(\"ascii\");\n        if (boolChaincode) {\n          result.chainCode = response\n            .slice(\n              1 + publicKeyLength + 1 + addressLength,\n              1 + publicKeyLength + 1 + addressLength + 32\n            )\n            .toString(\"hex\");\n        }\n        return result;\n      });\n  }\n\n  /**\n   * This commands provides a trusted description of an ERC 20 token\n   * to associate a contract address with a ticker and number of decimals.\n   *\n   * It shall be run immediately before performing a transaction involving a contract\n   * calling this contract address to display the proper token information to the user if necessary.\n   *\n   * @param {*} info: a blob from \"erc20.js\" utilities that contains all token information.\n   *\n   * @example\n   * import { byContractAddress } from \"@ledgerhq/hw-app-eth/erc20\"\n   * const zrxInfo = byContractAddress(\"0xe41d2489571d322189246dafa5ebde1f4699f498\")\n   * if (zrxInfo) await appEth.provideERC20TokenInformation(zrxInfo)\n   * const signed = await appEth.signTransaction(path, rawTxHex)\n   */\n  provideERC20TokenInformation({ data }: { data: Buffer }): Promise<boolean> {\n    return this.transport.send(0xe0, 0x0a, 0x00, 0x00, data).then(\n      () => true,\n      (e) => {\n        if (e && e.statusCode === 0x6d00) {\n          // this case happen for older version of ETH app, since older app version had the ERC20 data hardcoded, it's fine to assume it worked.\n          // we return a flag to know if the call was effective or not\n          return false;\n        }\n        throw e;\n      }\n    );\n  }\n\n  /**\n   * You can sign a transaction and retrieve v, r, s given the raw transaction and the BIP 32 path of the account to sign\n   * @example\n   eth.signTransaction(\"44'/60'/0'/0/0\", \"e8018504e3b292008252089428ee52a8f3d6e5d15f8b131996950d7f296c7952872bd72a2487400080\").then(result => ...)\n   */\n  signTransaction(\n    path: string,\n    rawTxHex: string\n  ): Promise<{\n    s: string,\n    v: string,\n    r: string,\n  }> {\n    let paths = splitPath(path);\n    let offset = 0;\n    let rawTx = Buffer.from(rawTxHex, \"hex\");\n    let toSend = [];\n    let response;\n    // Check if the TX is encoded following EIP 155\n    let rlpTx = decode(rawTx);\n    let rlpOffset = 0;\n    let chainIdPrefix = \"\";\n    if (rlpTx.length > 6) {\n      let rlpVrs = encode(rlpTx.slice(-3));\n      rlpOffset = rawTx.length - (rlpVrs.length - 1);\n      const chainIdSrc = rlpTx[6];\n      const chainIdBuf = Buffer.alloc(4);\n      chainIdSrc.copy(chainIdBuf, 4 - chainIdSrc.length);\n      chainIdPrefix = (chainIdBuf.readUInt32BE(0) * 2 + 35)\n        .toString(16)\n        .slice(0, -2); // Drop the low byte, that comes from the ledger.\n      if (chainIdPrefix.length % 2 === 1) {\n        chainIdPrefix = \"0\" + chainIdPrefix;\n      }\n    }\n    while (offset !== rawTx.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 : 150;\n      let chunkSize =\n        offset + maxChunkSize > rawTx.length\n          ? rawTx.length - offset\n          : maxChunkSize;\n      if (rlpOffset != 0 && offset + chunkSize == rlpOffset) {\n        // Make sure that the chunk doesn't end right on the EIP 155 marker if set\n        chunkSize--;\n      }\n      let buffer = Buffer.alloc(\n        offset === 0 ? 1 + paths.length * 4 + chunkSize : chunkSize\n      );\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        rawTx.copy(buffer, 1 + 4 * paths.length, offset, offset + chunkSize);\n      } else {\n        rawTx.copy(buffer, 0, offset, offset + chunkSize);\n      }\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n    return foreach(toSend, (data, i) =>\n      this.transport\n        .send(0xe0, 0x04, i === 0 ? 0x00 : 0x80, 0x00, data)\n        .then((apduResponse) => {\n          response = apduResponse;\n        })\n    ).then(\n      () => {\n        const v = chainIdPrefix + response.slice(0, 1).toString(\"hex\");\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { v, r, s };\n      },\n      (e) => {\n        throw remapTransactionRelatedErrors(e);\n      }\n    );\n  }\n\n  /**\n   */\n  getAppConfiguration(): Promise<{\n    arbitraryDataEnabled: number,\n    erc20ProvisioningNecessary: number,\n    starkEnabled: number,\n    starkv2Supported: number,\n    version: string,\n  }> {\n    return this.transport.send(0xe0, 0x06, 0x00, 0x00).then((response) => {\n      let result = {};\n      result.arbitraryDataEnabled = response[0] & 0x01;\n      result.erc20ProvisioningNecessary = response[0] & 0x02;\n      result.starkEnabled = response[0] & 0x04;\n      result.starkv2Supported = response[0] & 0x08;\n      result.version = \"\" + response[1] + \".\" + response[2] + \".\" + response[3];\n      return result;\n    });\n  }\n\n  /**\n  * You can sign a message according to eth_sign RPC call and retrieve v, r, s given the message and the BIP 32 path of the account to sign.\n  * @example\neth.signPersonalMessage(\"44'/60'/0'/0/0\", Buffer.from(\"test\").toString(\"hex\")).then(result => {\n  var v = result['v'] - 27;\n  v = v.toString(16);\n  if (v.length < 2) {\n    v = \"0\" + v;\n  }\n  console.log(\"Signature 0x\" + result['r'] + result['s'] + v);\n})\n   */\n  signPersonalMessage(\n    path: string,\n    messageHex: string\n  ): Promise<{\n    v: number,\n    s: string,\n    r: string,\n  }> {\n    let paths = splitPath(path);\n    let offset = 0;\n    let message = Buffer.from(messageHex, \"hex\");\n    let toSend = [];\n    let response;\n    while (offset !== message.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 - 4 : 150;\n      let chunkSize =\n        offset + maxChunkSize > message.length\n          ? message.length - offset\n          : maxChunkSize;\n      let buffer = Buffer.alloc(\n        offset === 0 ? 1 + paths.length * 4 + 4 + chunkSize : chunkSize\n      );\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        buffer.writeUInt32BE(message.length, 1 + 4 * paths.length);\n        message.copy(\n          buffer,\n          1 + 4 * paths.length + 4,\n          offset,\n          offset + chunkSize\n        );\n      } else {\n        message.copy(buffer, 0, offset, offset + chunkSize);\n      }\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n    return foreach(toSend, (data, i) =>\n      this.transport\n        .send(0xe0, 0x08, i === 0 ? 0x00 : 0x80, 0x00, data)\n        .then((apduResponse) => {\n          response = apduResponse;\n        })\n    ).then(() => {\n      const v = response[0];\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return { v, r, s };\n    });\n  }\n\n  /**\n  * Sign a prepared message following web3.eth.signTypedData specification. The host computes the domain separator and hashStruct(message)\n  * @example\n  eth.signEIP712HashedMessage(\"44'/60'/0'/0/0\", Buffer.from(\"0101010101010101010101010101010101010101010101010101010101010101\").toString(\"hex\"), Buffer.from(\"0202020202020202020202020202020202020202020202020202020202020202\").toString(\"hex\")).then(result => {\n  var v = result['v'] - 27;\n  v = v.toString(16);\n  if (v.length < 2) {\n    v = \"0\" + v;\n  }\n  console.log(\"Signature 0x\" + result['r'] + result['s'] + v);\n})\n   */\n  signEIP712HashedMessage(\n    path: string,\n    domainSeparatorHex: string,\n    hashStructMessageHex: string\n  ): Promise<{\n    v: number,\n    s: string,\n    r: string,\n  }> {\n    const domainSeparator = hexBuffer(domainSeparatorHex);\n    const hashStruct = hexBuffer(hashStructMessageHex);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4 + 32 + 32, 0);\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    domainSeparator.copy(buffer, offset);\n    offset += 32;\n    hashStruct.copy(buffer, offset);\n    return this.transport\n      .send(0xe0, 0x0c, 0x00, 0x00, buffer)\n      .then((response) => {\n        const v = response[0];\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { v, r, s };\n      });\n  }\n\n  /**\n   * get Stark public key for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @return the Stark public key\n   */\n  starkGetPublicKey(path: string, boolDisplay?: boolean): Promise<Buffer> {\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport\n      .send(0xf0, 0x02, boolDisplay ? 0x01 : 0x00, 0x00, buffer)\n      .then((response) => {\n        return response.slice(0, response.length - 2);\n      });\n  }\n\n  /**\n   * sign a Stark order\n   * @param path a path in BIP 32 format\n   * @option sourceTokenAddress contract address of the source token (not present for ETH)\n   * @param sourceQuantization quantization used for the source token\n   * @option destinationTokenAddress contract address of the destination token (not present for ETH)\n   * @param destinationQuantization quantization used for the destination token\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountSell amount to sell\n   * @param amountBuy amount to buy\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n  starkSignOrder(\n    path: string,\n    sourceTokenAddress?: string,\n    sourceQuantization: BigNumber,\n    destinationTokenAddress?: string,\n    destinationQuantization: BigNumber,\n    sourceVault: number,\n    destinationVault: number,\n    amountSell: BigNumber,\n    amountBuy: BigNumber,\n    nonce: number,\n    timestamp: number\n  ): Promise<Buffer> {\n    const sourceTokenAddressHex = maybeHexBuffer(sourceTokenAddress);\n    const destinationTokenAddressHex = maybeHexBuffer(destinationTokenAddress);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(\n      1 + paths.length * 4 + 20 + 32 + 20 + 32 + 4 + 4 + 8 + 8 + 4 + 4,\n      0\n    );\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    if (sourceTokenAddressHex) {\n      sourceTokenAddressHex.copy(buffer, offset);\n    }\n    offset += 20;\n    Buffer.from(sourceQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 32;\n    if (destinationTokenAddressHex) {\n      destinationTokenAddressHex.copy(buffer, offset);\n    }\n    offset += 20;\n    Buffer.from(\n      destinationQuantization.toString(16).padStart(64, \"0\"),\n      \"hex\"\n    ).copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountSell.toString(16).padStart(16, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 8;\n    Buffer.from(amountBuy.toString(16).padStart(16, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport\n      .send(0xf0, 0x04, 0x01, 0x00, buffer)\n      .then((response) => {\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { r, s };\n      });\n  }\n\n  /**\n   * sign a Stark order using the Starkex V2 protocol\n   * @param path a path in BIP 32 format\n   * @option sourceTokenAddress contract address of the source token (not present for ETH)\n   * @param sourceQuantizationType quantization type used for the source token\n   * @option sourceQuantization quantization used for the source token (not present for erc 721 or mintable erc 721)\n   * @option sourceMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the source token\n   * @option destinationTokenAddress contract address of the destination token (not present for ETH)\n   * @param destinationQuantizationType quantization type used for the destination token\n   * @option destinationQuantization quantization used for the destination token (not present for erc 721 or mintable erc 721)\n   * @option destinationMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the destination token\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountSell amount to sell\n   * @param amountBuy amount to buy\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n  starkSignOrder_v2(\n    path: string,\n    sourceTokenAddress?: string,\n    sourceQuantizationType: StarkQuantizationType,\n    sourceQuantization?: BigNumber,\n    sourceMintableBlobOrTokenId?: BigNumber,\n    destinationTokenAddress?: string,\n    destinationQuantizationType: StarkQuantizationType,\n    destinationQuantization?: BigNumber,\n    destinationMintableBlobOrTokenId?: BigNumber,\n    sourceVault: number,\n    destinationVault: number,\n    amountSell: BigNumber,\n    amountBuy: BigNumber,\n    nonce: number,\n    timestamp: number\n  ): Promise<Buffer> {\n    const sourceTokenAddressHex = maybeHexBuffer(sourceTokenAddress);\n    const destinationTokenAddressHex = maybeHexBuffer(destinationTokenAddress);\n    if (!(sourceQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\n        \"eth.starkSignOrderv2 invalid source quantization type=\" +\n          sourceQuantizationType\n      );\n    }\n    if (!(destinationQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\n        \"eth.starkSignOrderv2 invalid destination quantization type=\" +\n          destinationQuantizationType\n      );\n    }\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(\n      1 +\n        paths.length * 4 +\n        1 +\n        20 +\n        32 +\n        32 +\n        1 +\n        20 +\n        32 +\n        32 +\n        4 +\n        4 +\n        8 +\n        8 +\n        4 +\n        4,\n      0\n    );\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    buffer[offset] = starkQuantizationTypeMap[sourceQuantizationType];\n    offset++;\n    if (sourceTokenAddressHex) {\n      sourceTokenAddressHex.copy(buffer, offset);\n    }\n    offset += 20;\n    if (sourceQuantization) {\n      Buffer.from(\n        sourceQuantization.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    if (sourceMintableBlobOrTokenId) {\n      Buffer.from(\n        sourceMintableBlobOrTokenId.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    buffer[offset] = starkQuantizationTypeMap[destinationQuantizationType];\n    offset++;\n    if (destinationTokenAddressHex) {\n      destinationTokenAddressHex.copy(buffer, offset);\n    }\n    offset += 20;\n    if (destinationQuantization) {\n      Buffer.from(\n        destinationQuantization.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    if (destinationMintableBlobOrTokenId) {\n      Buffer.from(\n        destinationMintableBlobOrTokenId.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountSell.toString(16).padStart(16, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 8;\n    Buffer.from(amountBuy.toString(16).padStart(16, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport\n      .send(0xf0, 0x04, 0x03, 0x00, buffer)\n      .then((response) => {\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { r, s };\n      });\n  }\n\n  /**\n   * sign a Stark transfer\n   * @param path a path in BIP 32 format\n   * @option transferTokenAddress contract address of the token to be transferred (not present for ETH)\n   * @param transferQuantization quantization used for the token to be transferred\n   * @param targetPublicKey target Stark public key\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountTransfer amount to transfer\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n  starkSignTransfer(\n    path: string,\n    transferTokenAddress?: string,\n    transferQuantization: BigNumber,\n    targetPublicKey: string,\n    sourceVault: number,\n    destinationVault: number,\n    amountTransfer: BigNumber,\n    nonce: number,\n    timestamp: number\n  ): Promise<Buffer> {\n    const transferTokenAddressHex = maybeHexBuffer(transferTokenAddress);\n    const targetPublicKeyHex = hexBuffer(targetPublicKey);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(\n      1 + paths.length * 4 + 20 + 32 + 32 + 4 + 4 + 8 + 4 + 4,\n      0\n    );\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    if (transferTokenAddressHex) {\n      transferTokenAddressHex.copy(buffer, offset);\n    }\n    offset += 20;\n    Buffer.from(\n      transferQuantization.toString(16).padStart(64, \"0\"),\n      \"hex\"\n    ).copy(buffer, offset);\n    offset += 32;\n    targetPublicKeyHex.copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountTransfer.toString(16).padStart(16, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport\n      .send(0xf0, 0x04, 0x02, 0x00, buffer)\n      .then((response) => {\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { r, s };\n      });\n  }\n\n  /**\n   * sign a Stark transfer or conditional transfer using the Starkex V2 protocol\n   * @param path a path in BIP 32 format\n   * @option transferTokenAddress contract address of the token to be transferred (not present for ETH)\n   * @param transferQuantizationType quantization type used for the token to be transferred\n   * @option transferQuantization quantization used for the token to be transferred (not present for erc 721 or mintable erc 721)\n   * @option transferMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the token to be transferred\n   * @param targetPublicKey target Stark public key\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountTransfer amount to transfer\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @option conditionalTransferAddress onchain address of the condition for a conditional transfer\n   * @option conditionalTransferFact fact associated to the condition for a conditional transfer\n   * @return the signature\n   */\n  starkSignTransfer_v2(\n    path: string,\n    transferTokenAddress?: string,\n    transferQuantizationType: StarkQuantizationType,\n    transferQuantization?: BigNumber,\n    transferMintableBlobOrTokenId?: BigNumber,\n    targetPublicKey: string,\n    sourceVault: number,\n    destinationVault: number,\n    amountTransfer: BigNumber,\n    nonce: number,\n    timestamp: number,\n    conditionalTransferAddress?: string,\n    conditionalTransferFact?: BigNumber\n  ): Promise<Buffer> {\n    const transferTokenAddressHex = maybeHexBuffer(transferTokenAddress);\n    const targetPublicKeyHex = hexBuffer(targetPublicKey);\n    const conditionalTransferAddressHex = maybeHexBuffer(\n      conditionalTransferAddress\n    );\n    if (!(transferQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\n        \"eth.starkSignTransferv2 invalid quantization type=\" +\n          transferQuantizationType\n      );\n    }\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(\n      1 +\n        paths.length * 4 +\n        1 +\n        20 +\n        32 +\n        32 +\n        32 +\n        4 +\n        4 +\n        8 +\n        4 +\n        4 +\n        (conditionalTransferAddressHex ? 32 + 20 : 0),\n      0\n    );\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    buffer[offset] = starkQuantizationTypeMap[transferQuantizationType];\n    offset++;\n    if (transferTokenAddressHex) {\n      transferTokenAddressHex.copy(buffer, offset);\n    }\n    offset += 20;\n    if (transferQuantization) {\n      Buffer.from(\n        transferQuantization.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    if (transferMintableBlobOrTokenId) {\n      Buffer.from(\n        transferMintableBlobOrTokenId.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    targetPublicKeyHex.copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountTransfer.toString(16).padStart(16, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    if (conditionalTransferAddressHex && conditionalTransferFact) {\n      offset += 4;\n      Buffer.from(\n        conditionalTransferFact.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n      offset += 32;\n      conditionalTransferAddressHex.copy(buffer, offset);\n    }\n    return this.transport\n      .send(\n        0xf0,\n        0x04,\n        conditionalTransferAddressHex ? 0x05 : 0x04,\n        0x00,\n        buffer\n      )\n      .then((response) => {\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { r, s };\n      });\n  }\n\n  /**\n   * provide quantization information before singing a deposit or withdrawal Stark powered contract call\n   *\n   * It shall be run following a provideERC20TokenInformation call for the given contract\n   *\n   * @param operationContract contract address of the token to be transferred (not present for ETH)\n   * @param operationQuantization quantization used for the token to be transferred\n   */\n  starkProvideQuantum(\n    operationContract?: string,\n    operationQuantization: BigNumber\n  ): Promise<boolean> {\n    const operationContractHex = maybeHexBuffer(operationContract);\n    let buffer = Buffer.alloc(20 + 32, 0);\n    if (operationContractHex) {\n      operationContractHex.copy(buffer, 0);\n    }\n    Buffer.from(\n      operationQuantization.toString(16).padStart(64, \"0\"),\n      \"hex\"\n    ).copy(buffer, 20);\n    return this.transport.send(0xf0, 0x08, 0x00, 0x00, buffer).then(\n      () => true,\n      (e) => {\n        if (e && e.statusCode === 0x6d00) {\n          // this case happen for ETH application versions not supporting Stark extensions\n          return false;\n        }\n        throw e;\n      }\n    );\n  }\n\n  /**\n   * provide quantization information before singing a deposit or withdrawal Stark powered contract call using the Starkex V2 protocol\n   *\n   * It shall be run following a provideERC20TokenInformation call for the given contract\n   *\n   * @param operationContract contract address of the token to be transferred (not present for ETH)\n   * @param operationQuantizationType quantization type of the token to be transferred\n   * @option operationQuantization quantization used for the token to be transferred (not present for erc 721 or mintable erc 721)\n   * @option operationMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) of the token to be transferred\n   */\n  starkProvideQuantum_v2(\n    operationContract?: string,\n    operationQuantizationType: StarkQuantizationType,\n    operationQuantization?: BigNumber,\n    operationMintableBlobOrTokenId?: BigNumber\n  ): Promise<boolean> {\n    const operationContractHex = maybeHexBuffer(operationContract);\n    if (!(operationQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\n        \"eth.starkProvideQuantumV2 invalid quantization type=\" +\n          operationQuantizationType\n      );\n    }\n    let buffer = Buffer.alloc(20 + 32 + 32, 0);\n    let offset = 0;\n    if (operationContractHex) {\n      operationContractHex.copy(buffer, offset);\n    }\n    offset += 20;\n    if (operationQuantization) {\n      Buffer.from(\n        operationQuantization.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    if (operationMintableBlobOrTokenId) {\n      Buffer.from(\n        operationMintableBlobOrTokenId.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    return this.transport\n      .send(\n        0xf0,\n        0x08,\n        starkQuantizationTypeMap[operationQuantizationType],\n        0x00,\n        buffer\n      )\n      .then(\n        () => true,\n        (e) => {\n          if (e && e.statusCode === 0x6d00) {\n            // this case happen for ETH application versions not supporting Stark extensions\n            return false;\n          }\n          throw e;\n        }\n      );\n  }\n\n  /**\n   * sign the given hash over the Stark curve\n   * It is intended for speed of execution in case an unknown Stark model is pushed and should be avoided as much as possible.\n   * @param path a path in BIP 32 format\n   * @param hash hexadecimal hash to sign\n   * @return the signature\n   */\n  starkUnsafeSign(path: string, hash: string): Promise<Buffer> {\n    const hashHex = hexBuffer(hash);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4 + 32);\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    hashHex.copy(buffer, offset);\n    return this.transport\n      .send(0xf0, 0x0a, 0x00, 0x00, buffer)\n      .then((response) => {\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { r, s };\n      });\n  }\n\n  /**\n   * get an Ethereum 2 BLS-12 381 public key for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @return an object with a publicKey\n   * @example\n   * eth.eth2GetPublicKey(\"12381/3600/0/0\").then(o => o.publicKey)\n   */\n  eth2GetPublicKey(\n    path: string,\n    boolDisplay?: boolean\n  ): Promise<{\n    publicKey: string,\n  }> {\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport\n      .send(0xe0, 0x0e, boolDisplay ? 0x01 : 0x00, 0x00, buffer)\n      .then((response) => {\n        let result = {};\n        result.publicKey = response.slice(0, -2).toString(\"hex\");\n        return result;\n      });\n  }\n\n  /**\n   * Set the index of a Withdrawal key used as withdrawal credentials in an ETH 2 deposit contract call signature\n   *\n   * It shall be run before the ETH 2 deposit transaction is signed. If not called, the index is set to 0\n   *\n   * @param withdrawalIndex index path in the EIP 2334 path m/12381/3600/withdrawalIndex/0\n   * @return True if the method was executed successfully\n   */\n  eth2SetWithdrawalIndex(withdrawalIndex: number): Promise<boolean> {\n    let buffer = Buffer.alloc(4, 0);\n    buffer.writeUInt32BE(withdrawalIndex, 0);\n    return this.transport.send(0xe0, 0x10, 0x00, 0x00, buffer).then(\n      () => true,\n      (e) => {\n        if (e && e.statusCode === 0x6d00) {\n          // this case happen for ETH application versions not supporting ETH 2\n          return false;\n        }\n        throw e;\n      }\n    );\n  }\n}\n","/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//@flow\n\ntype Defer<T> = {\n  promise: Promise<T>,\n  resolve: (T) => void,\n  reject: (any) => void,\n};\n\nexport function defer<T>(): Defer<T> {\n  let resolve, reject;\n  let promise = new Promise(function (success, failure) {\n    resolve = success;\n    reject = failure;\n  });\n  if (!resolve || !reject) throw \"defer() error\"; // this never happens and is just to make flow happy\n  return { promise, resolve, reject };\n}\n\n// TODO use bip32-path library\nexport function splitPath(path: string): number[] {\n  let result = [];\n  let components = path.split(\"/\");\n  components.forEach((element) => {\n    let number = parseInt(element, 10);\n    if (isNaN(number)) {\n      return; // FIXME shouldn't it throws instead?\n    }\n    if (element.length > 1 && element[element.length - 1] === \"'\") {\n      number += 0x80000000;\n    }\n    result.push(number);\n  });\n  return result;\n}\n\n// TODO use async await\n\nexport function eachSeries<A>(arr: A[], fun: (A) => Promise<*>): Promise<*> {\n  return arr.reduce((p, e) => p.then(() => fun(e)), Promise.resolve());\n}\n\nexport function foreach<T, A>(\n  arr: T[],\n  callback: (T, number) => Promise<A>\n): Promise<A[]> {\n  function iterate(index, array, result) {\n    if (index >= array.length) {\n      return result;\n    } else\n      return callback(array[index], index).then(function (res) {\n        result.push(res);\n        return iterate(index + 1, array, result);\n      });\n  }\n  return Promise.resolve().then(() => iterate(0, arr, []));\n}\n\nexport function doIf(\n  condition: boolean,\n  callback: () => any | Promise<any>\n): Promise<void> {\n  return Promise.resolve().then(() => {\n    if (condition) {\n      return callback();\n    }\n  });\n}\n\nexport function asyncWhile<T>(\n  predicate: () => boolean,\n  callback: () => Promise<T>\n): Promise<Array<T>> {\n  function iterate(result) {\n    if (!predicate()) {\n      return result;\n    } else {\n      return callback().then((res) => {\n        result.push(res);\n        return iterate(result);\n      });\n    }\n  }\n  return Promise.resolve([]).then(iterate);\n}\n","/* eslint-disable no-continue */\r\n/* eslint-disable no-unused-vars */\r\n/* eslint-disable no-param-reassign */\r\n/* eslint-disable no-prototype-builtins */\r\nvar errorClasses = {};\r\nvar deserializers = {};\r\nvar addCustomErrorDeserializer = function (name, deserializer) {\r\n    deserializers[name] = deserializer;\r\n};\r\nvar createCustomErrorClass = function (name) {\r\n    var C = function CustomError(message, fields) {\r\n        Object.assign(this, fields);\r\n        this.name = name;\r\n        this.message = message || name;\r\n        this.stack = new Error().stack;\r\n    };\r\n    C.prototype = new Error();\r\n    errorClasses[name] = C;\r\n    return C;\r\n};\r\n// inspired from https://github.com/programble/errio/blob/master/index.js\r\nvar deserializeError = function (object) {\r\n    if (typeof object === \"object\" && object) {\r\n        try {\r\n            // $FlowFixMe FIXME HACK\r\n            var msg = JSON.parse(object.message);\r\n            if (msg.message && msg.name) {\r\n                object = msg;\r\n            }\r\n        }\r\n        catch (e) {\r\n            // nothing\r\n        }\r\n        var error = void 0;\r\n        if (typeof object.name === \"string\") {\r\n            var name_1 = object.name;\r\n            var des = deserializers[name_1];\r\n            if (des) {\r\n                error = des(object);\r\n            }\r\n            else {\r\n                var constructor = name_1 === \"Error\" ? Error : errorClasses[name_1];\r\n                if (!constructor) {\r\n                    console.warn(\"deserializing an unknown class '\" + name_1 + \"'\");\r\n                    constructor = createCustomErrorClass(name_1);\r\n                }\r\n                error = Object.create(constructor.prototype);\r\n                try {\r\n                    for (var prop in object) {\r\n                        if (object.hasOwnProperty(prop)) {\r\n                            error[prop] = object[prop];\r\n                        }\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    // sometimes setting a property can fail (e.g. .name)\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            error = new Error(object.message);\r\n        }\r\n        if (!error.stack && Error.captureStackTrace) {\r\n            Error.captureStackTrace(error, deserializeError);\r\n        }\r\n        return error;\r\n    }\r\n    return new Error(String(object));\r\n};\r\n// inspired from https://github.com/sindresorhus/serialize-error/blob/master/index.js\r\nvar serializeError = function (value) {\r\n    if (!value)\r\n        return value;\r\n    if (typeof value === \"object\") {\r\n        return destroyCircular(value, []);\r\n    }\r\n    if (typeof value === \"function\") {\r\n        return \"[Function: \" + (value.name || \"anonymous\") + \"]\";\r\n    }\r\n    return value;\r\n};\r\n// https://www.npmjs.com/package/destroy-circular\r\nfunction destroyCircular(from, seen) {\r\n    var to = {};\r\n    seen.push(from);\r\n    for (var _i = 0, _a = Object.keys(from); _i < _a.length; _i++) {\r\n        var key = _a[_i];\r\n        var value = from[key];\r\n        if (typeof value === \"function\") {\r\n            continue;\r\n        }\r\n        if (!value || typeof value !== \"object\") {\r\n            to[key] = value;\r\n            continue;\r\n        }\r\n        if (seen.indexOf(from[key]) === -1) {\r\n            to[key] = destroyCircular(from[key], seen.slice(0));\r\n            continue;\r\n        }\r\n        to[key] = \"[Circular]\";\r\n    }\r\n    if (typeof from.name === \"string\") {\r\n        to.name = from.name;\r\n    }\r\n    if (typeof from.message === \"string\") {\r\n        to.message = from.message;\r\n    }\r\n    if (typeof from.stack === \"string\") {\r\n        to.stack = from.stack;\r\n    }\r\n    return to;\r\n}\n\nvar AccountNameRequiredError = createCustomErrorClass(\"AccountNameRequired\");\r\nvar AccountNotSupported = createCustomErrorClass(\"AccountNotSupported\");\r\nvar AmountRequired = createCustomErrorClass(\"AmountRequired\");\r\nvar BluetoothRequired = createCustomErrorClass(\"BluetoothRequired\");\r\nvar BtcUnmatchedApp = createCustomErrorClass(\"BtcUnmatchedApp\");\r\nvar CantOpenDevice = createCustomErrorClass(\"CantOpenDevice\");\r\nvar CashAddrNotSupported = createCustomErrorClass(\"CashAddrNotSupported\");\r\nvar CurrencyNotSupported = createCustomErrorClass(\"CurrencyNotSupported\");\r\nvar DeviceAppVerifyNotSupported = createCustomErrorClass(\"DeviceAppVerifyNotSupported\");\r\nvar DeviceGenuineSocketEarlyClose = createCustomErrorClass(\"DeviceGenuineSocketEarlyClose\");\r\nvar DeviceNotGenuineError = createCustomErrorClass(\"DeviceNotGenuine\");\r\nvar DeviceOnDashboardExpected = createCustomErrorClass(\"DeviceOnDashboardExpected\");\r\nvar DeviceOnDashboardUnexpected = createCustomErrorClass(\"DeviceOnDashboardUnexpected\");\r\nvar DeviceInOSUExpected = createCustomErrorClass(\"DeviceInOSUExpected\");\r\nvar DeviceHalted = createCustomErrorClass(\"DeviceHalted\");\r\nvar DeviceNameInvalid = createCustomErrorClass(\"DeviceNameInvalid\");\r\nvar DeviceSocketFail = createCustomErrorClass(\"DeviceSocketFail\");\r\nvar DeviceSocketNoBulkStatus = createCustomErrorClass(\"DeviceSocketNoBulkStatus\");\r\nvar DisconnectedDevice = createCustomErrorClass(\"DisconnectedDevice\");\r\nvar DisconnectedDeviceDuringOperation = createCustomErrorClass(\"DisconnectedDeviceDuringOperation\");\r\nvar EnpointConfigError = createCustomErrorClass(\"EnpointConfig\");\r\nvar EthAppPleaseEnableContractData = createCustomErrorClass(\"EthAppPleaseEnableContractData\");\r\nvar FeeEstimationFailed = createCustomErrorClass(\"FeeEstimationFailed\");\r\nvar FirmwareNotRecognized = createCustomErrorClass(\"FirmwareNotRecognized\");\r\nvar HardResetFail = createCustomErrorClass(\"HardResetFail\");\r\nvar InvalidXRPTag = createCustomErrorClass(\"InvalidXRPTag\");\r\nvar InvalidAddress = createCustomErrorClass(\"InvalidAddress\");\r\nvar InvalidAddressBecauseDestinationIsAlsoSource = createCustomErrorClass(\"InvalidAddressBecauseDestinationIsAlsoSource\");\r\nvar LatestMCUInstalledError = createCustomErrorClass(\"LatestMCUInstalledError\");\r\nvar UnknownMCU = createCustomErrorClass(\"UnknownMCU\");\r\nvar LedgerAPIError = createCustomErrorClass(\"LedgerAPIError\");\r\nvar LedgerAPIErrorWithMessage = createCustomErrorClass(\"LedgerAPIErrorWithMessage\");\r\nvar LedgerAPINotAvailable = createCustomErrorClass(\"LedgerAPINotAvailable\");\r\nvar ManagerAppAlreadyInstalledError = createCustomErrorClass(\"ManagerAppAlreadyInstalled\");\r\nvar ManagerAppRelyOnBTCError = createCustomErrorClass(\"ManagerAppRelyOnBTC\");\r\nvar ManagerAppDepInstallRequired = createCustomErrorClass(\"ManagerAppDepInstallRequired\");\r\nvar ManagerAppDepUninstallRequired = createCustomErrorClass(\"ManagerAppDepUninstallRequired\");\r\nvar ManagerDeviceLockedError = createCustomErrorClass(\"ManagerDeviceLocked\");\r\nvar ManagerFirmwareNotEnoughSpaceError = createCustomErrorClass(\"ManagerFirmwareNotEnoughSpace\");\r\nvar ManagerNotEnoughSpaceError = createCustomErrorClass(\"ManagerNotEnoughSpace\");\r\nvar ManagerUninstallBTCDep = createCustomErrorClass(\"ManagerUninstallBTCDep\");\r\nvar NetworkDown = createCustomErrorClass(\"NetworkDown\");\r\nvar NoAddressesFound = createCustomErrorClass(\"NoAddressesFound\");\r\nvar NotEnoughBalance = createCustomErrorClass(\"NotEnoughBalance\");\r\nvar NotEnoughBalanceToDelegate = createCustomErrorClass(\"NotEnoughBalanceToDelegate\");\r\nvar NotEnoughBalanceInParentAccount = createCustomErrorClass(\"NotEnoughBalanceInParentAccount\");\r\nvar NotEnoughSpendableBalance = createCustomErrorClass(\"NotEnoughSpendableBalance\");\r\nvar NotEnoughBalanceBecauseDestinationNotCreated = createCustomErrorClass(\"NotEnoughBalanceBecauseDestinationNotCreated\");\r\nvar NoAccessToCamera = createCustomErrorClass(\"NoAccessToCamera\");\r\nvar NotEnoughGas = createCustomErrorClass(\"NotEnoughGas\");\r\nvar NotSupportedLegacyAddress = createCustomErrorClass(\"NotSupportedLegacyAddress\");\r\nvar GasLessThanEstimate = createCustomErrorClass(\"GasLessThanEstimate\");\r\nvar PasswordsDontMatchError = createCustomErrorClass(\"PasswordsDontMatch\");\r\nvar PasswordIncorrectError = createCustomErrorClass(\"PasswordIncorrect\");\r\nvar RecommendSubAccountsToEmpty = createCustomErrorClass(\"RecommendSubAccountsToEmpty\");\r\nvar RecommendUndelegation = createCustomErrorClass(\"RecommendUndelegation\");\r\nvar TimeoutTagged = createCustomErrorClass(\"TimeoutTagged\");\r\nvar UnexpectedBootloader = createCustomErrorClass(\"UnexpectedBootloader\");\r\nvar MCUNotGenuineToDashboard = createCustomErrorClass(\"MCUNotGenuineToDashboard\");\r\nvar RecipientRequired = createCustomErrorClass(\"RecipientRequired\");\r\nvar UnavailableTezosOriginatedAccountReceive = createCustomErrorClass(\"UnavailableTezosOriginatedAccountReceive\");\r\nvar UnavailableTezosOriginatedAccountSend = createCustomErrorClass(\"UnavailableTezosOriginatedAccountSend\");\r\nvar UpdateFetchFileFail = createCustomErrorClass(\"UpdateFetchFileFail\");\r\nvar UpdateIncorrectHash = createCustomErrorClass(\"UpdateIncorrectHash\");\r\nvar UpdateIncorrectSig = createCustomErrorClass(\"UpdateIncorrectSig\");\r\nvar UpdateYourApp = createCustomErrorClass(\"UpdateYourApp\");\r\nvar UserRefusedDeviceNameChange = createCustomErrorClass(\"UserRefusedDeviceNameChange\");\r\nvar UserRefusedAddress = createCustomErrorClass(\"UserRefusedAddress\");\r\nvar UserRefusedFirmwareUpdate = createCustomErrorClass(\"UserRefusedFirmwareUpdate\");\r\nvar UserRefusedAllowManager = createCustomErrorClass(\"UserRefusedAllowManager\");\r\nvar UserRefusedOnDevice = createCustomErrorClass(\"UserRefusedOnDevice\"); // TODO rename because it's just for transaction refusal\r\nvar TransportOpenUserCancelled = createCustomErrorClass(\"TransportOpenUserCancelled\");\r\nvar TransportInterfaceNotAvailable = createCustomErrorClass(\"TransportInterfaceNotAvailable\");\r\nvar TransportRaceCondition = createCustomErrorClass(\"TransportRaceCondition\");\r\nvar TransportWebUSBGestureRequired = createCustomErrorClass(\"TransportWebUSBGestureRequired\");\r\nvar DeviceShouldStayInApp = createCustomErrorClass(\"DeviceShouldStayInApp\");\r\nvar WebsocketConnectionError = createCustomErrorClass(\"WebsocketConnectionError\");\r\nvar WebsocketConnectionFailed = createCustomErrorClass(\"WebsocketConnectionFailed\");\r\nvar WrongDeviceForAccount = createCustomErrorClass(\"WrongDeviceForAccount\");\r\nvar WrongAppForCurrency = createCustomErrorClass(\"WrongAppForCurrency\");\r\nvar ETHAddressNonEIP = createCustomErrorClass(\"ETHAddressNonEIP\");\r\nvar CantScanQRCode = createCustomErrorClass(\"CantScanQRCode\");\r\nvar FeeNotLoaded = createCustomErrorClass(\"FeeNotLoaded\");\r\nvar FeeRequired = createCustomErrorClass(\"FeeRequired\");\r\nvar FeeTooHigh = createCustomErrorClass(\"FeeTooHigh\");\r\nvar SyncError = createCustomErrorClass(\"SyncError\");\r\nvar PairingFailed = createCustomErrorClass(\"PairingFailed\");\r\nvar GenuineCheckFailed = createCustomErrorClass(\"GenuineCheckFailed\");\r\nvar LedgerAPI4xx = createCustomErrorClass(\"LedgerAPI4xx\");\r\nvar LedgerAPI5xx = createCustomErrorClass(\"LedgerAPI5xx\");\r\nvar FirmwareOrAppUpdateRequired = createCustomErrorClass(\"FirmwareOrAppUpdateRequired\");\r\n// db stuff, no need to translate\r\nvar NoDBPathGiven = createCustomErrorClass(\"NoDBPathGiven\");\r\nvar DBWrongPassword = createCustomErrorClass(\"DBWrongPassword\");\r\nvar DBNotReset = createCustomErrorClass(\"DBNotReset\");\r\n/**\r\n * TransportError is used for any generic transport errors.\r\n * e.g. Error thrown when data received by exchanges are incorrect or if exchanged failed to communicate with the device for various reason.\r\n */\r\nfunction TransportError(message, id) {\r\n    this.name = \"TransportError\";\r\n    this.message = message;\r\n    this.stack = new Error().stack;\r\n    this.id = id;\r\n}\r\nTransportError.prototype = new Error();\r\naddCustomErrorDeserializer(\"TransportError\", function (e) { return new TransportError(e.message, e.id); });\r\nvar StatusCodes = {\r\n    PIN_REMAINING_ATTEMPTS: 0x63c0,\r\n    INCORRECT_LENGTH: 0x6700,\r\n    MISSING_CRITICAL_PARAMETER: 0x6800,\r\n    COMMAND_INCOMPATIBLE_FILE_STRUCTURE: 0x6981,\r\n    SECURITY_STATUS_NOT_SATISFIED: 0x6982,\r\n    CONDITIONS_OF_USE_NOT_SATISFIED: 0x6985,\r\n    INCORRECT_DATA: 0x6a80,\r\n    NOT_ENOUGH_MEMORY_SPACE: 0x6a84,\r\n    REFERENCED_DATA_NOT_FOUND: 0x6a88,\r\n    FILE_ALREADY_EXISTS: 0x6a89,\r\n    INCORRECT_P1_P2: 0x6b00,\r\n    INS_NOT_SUPPORTED: 0x6d00,\r\n    CLA_NOT_SUPPORTED: 0x6e00,\r\n    TECHNICAL_PROBLEM: 0x6f00,\r\n    OK: 0x9000,\r\n    MEMORY_PROBLEM: 0x9240,\r\n    NO_EF_SELECTED: 0x9400,\r\n    INVALID_OFFSET: 0x9402,\r\n    FILE_NOT_FOUND: 0x9404,\r\n    INCONSISTENT_FILE: 0x9408,\r\n    ALGORITHM_NOT_SUPPORTED: 0x9484,\r\n    INVALID_KCV: 0x9485,\r\n    CODE_NOT_INITIALIZED: 0x9802,\r\n    ACCESS_CONDITION_NOT_FULFILLED: 0x9804,\r\n    CONTRADICTION_SECRET_CODE_STATUS: 0x9808,\r\n    CONTRADICTION_INVALIDATION: 0x9810,\r\n    CODE_BLOCKED: 0x9840,\r\n    MAX_VALUE_REACHED: 0x9850,\r\n    GP_AUTH_FAILED: 0x6300,\r\n    LICENSING: 0x6f42,\r\n    HALTED: 0x6faa,\r\n};\r\nfunction getAltStatusMessage(code) {\r\n    switch (code) {\r\n        // improve text of most common errors\r\n        case 0x6700:\r\n            return \"Incorrect length\";\r\n        case 0x6800:\r\n            return \"Missing critical parameter\";\r\n        case 0x6982:\r\n            return \"Security not satisfied (dongle locked or have invalid access rights)\";\r\n        case 0x6985:\r\n            return \"Condition of use not satisfied (denied by the user?)\";\r\n        case 0x6a80:\r\n            return \"Invalid data received\";\r\n        case 0x6b00:\r\n            return \"Invalid parameter received\";\r\n    }\r\n    if (0x6f00 <= code && code <= 0x6fff) {\r\n        return \"Internal error, please report\";\r\n    }\r\n}\r\n/**\r\n * Error thrown when a device returned a non success status.\r\n * the error.statusCode is one of the `StatusCodes` exported by this library.\r\n */\r\nfunction TransportStatusError(statusCode) {\r\n    this.name = \"TransportStatusError\";\r\n    var statusText = Object.keys(StatusCodes).find(function (k) { return StatusCodes[k] === statusCode; }) ||\r\n        \"UNKNOWN_ERROR\";\r\n    var smsg = getAltStatusMessage(statusCode) || statusText;\r\n    var statusCodeStr = statusCode.toString(16);\r\n    this.message = \"Ledger device: \" + smsg + \" (0x\" + statusCodeStr + \")\";\r\n    this.stack = new Error().stack;\r\n    this.statusCode = statusCode;\r\n    this.statusText = statusText;\r\n}\r\nTransportStatusError.prototype = new Error();\r\naddCustomErrorDeserializer(\"TransportStatusError\", function (e) { return new TransportStatusError(e.statusCode); });\n\nexport { AccountNameRequiredError, AccountNotSupported, AmountRequired, BluetoothRequired, BtcUnmatchedApp, CantOpenDevice, CantScanQRCode, CashAddrNotSupported, CurrencyNotSupported, DBNotReset, DBWrongPassword, DeviceAppVerifyNotSupported, DeviceGenuineSocketEarlyClose, DeviceHalted, DeviceInOSUExpected, DeviceNameInvalid, DeviceNotGenuineError, DeviceOnDashboardExpected, DeviceOnDashboardUnexpected, DeviceShouldStayInApp, DeviceSocketFail, DeviceSocketNoBulkStatus, DisconnectedDevice, DisconnectedDeviceDuringOperation, ETHAddressNonEIP, EnpointConfigError, EthAppPleaseEnableContractData, FeeEstimationFailed, FeeNotLoaded, FeeRequired, FeeTooHigh, FirmwareNotRecognized, FirmwareOrAppUpdateRequired, GasLessThanEstimate, GenuineCheckFailed, HardResetFail, InvalidAddress, InvalidAddressBecauseDestinationIsAlsoSource, InvalidXRPTag, LatestMCUInstalledError, LedgerAPI4xx, LedgerAPI5xx, LedgerAPIError, LedgerAPIErrorWithMessage, LedgerAPINotAvailable, MCUNotGenuineToDashboard, ManagerAppAlreadyInstalledError, ManagerAppDepInstallRequired, ManagerAppDepUninstallRequired, ManagerAppRelyOnBTCError, ManagerDeviceLockedError, ManagerFirmwareNotEnoughSpaceError, ManagerNotEnoughSpaceError, ManagerUninstallBTCDep, NetworkDown, NoAccessToCamera, NoAddressesFound, NoDBPathGiven, NotEnoughBalance, NotEnoughBalanceBecauseDestinationNotCreated, NotEnoughBalanceInParentAccount, NotEnoughBalanceToDelegate, NotEnoughGas, NotEnoughSpendableBalance, NotSupportedLegacyAddress, PairingFailed, PasswordIncorrectError, PasswordsDontMatchError, RecipientRequired, RecommendSubAccountsToEmpty, RecommendUndelegation, StatusCodes, SyncError, TimeoutTagged, TransportError, TransportInterfaceNotAvailable, TransportOpenUserCancelled, TransportRaceCondition, TransportStatusError, TransportWebUSBGestureRequired, UnavailableTezosOriginatedAccountReceive, UnavailableTezosOriginatedAccountSend, UnexpectedBootloader, UnknownMCU, UpdateFetchFileFail, UpdateIncorrectHash, UpdateIncorrectSig, UpdateYourApp, UserRefusedAddress, UserRefusedAllowManager, UserRefusedDeviceNameChange, UserRefusedFirmwareUpdate, UserRefusedOnDevice, WebsocketConnectionError, WebsocketConnectionFailed, WrongAppForCurrency, WrongDeviceForAccount, addCustomErrorDeserializer, createCustomErrorClass, deserializeError, getAltStatusMessage, serializeError };\n"],"sourceRoot":""}