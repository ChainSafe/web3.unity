{"version":3,"sources":["../../src/TransportU2F.js","../node_modules/u2f-api/index.js","../node_modules/u2f-api/lib/u2f-api.js","../node_modules/u2f-api/lib/google-u2f-api.js"],"names":["wrapU2FTransportError","originalError","message","id","err","webSafe64","base64","attemptExchange","keyHandle","apdu","result","Buffer","i","key","wrapApdu","challenge","signRequest","version","appId","location","origin","log","timeoutMillis","response","signatureData","data","substring","transportInstances","constructor","scrambleKey","unwrap","a","this","e","u2fError","t","setScrambleKey","setUnwrap","close","Promise","TransportU2F","isSupported","list","supported","listen","observer","unsubscribed","type","descriptor","unsubscribe","module","exports","require","API","chromeApi","isBrowser","navigator","userAgent","isSafari","match","isEDGE","_backend","getBackend","resolve","reject","notSupported","u2f","native","window","sign","protocol","MessageChannel","ok","bind","ensureSupport","register","ErrorCodes","ErrorNames","makeError","msg","code","errorCode","error","Error","metaData","deferPromise","promise","ret","then","cancel","disconnect","backend","_ensureSupport","registerRequests","signRequests","timeout","Array","isArray","makeDefault","func","global","args","slice","call","arguments","apply","CANCELLED","OK","OTHER_ERROR","BAD_REQUEST","CONFIGURATION_UNSUPPORTED","DEVICE_INELIGIBLE","TIMEOUT","EXTENSION_ID","MessageTypes","Request","Response","SignRequest","SignResponse","RegisterRequest","RegisterResponse","port_","getMessagePort","callback","chrome","runtime","U2F_SIGN_REQUEST","sendMessage","lastError","getIframePort_","getChromeRuntimePort_","port","connect","setTimeout","WrappedChromeRuntimePort_","prototype","postMessage","addEventListener","eventName","handler","name","toLowerCase","onMessage","addListener","console","iframeOrigin","iframe","document","createElement","src","setAttribute","body","appendChild","hasCalledBack","channel","port1","ready","removeEventListener","start","contentWindow","port2","EXTENSION_TIMEOUT_SEC","waitingForPort_","reqCounter_","callbackMap_","getPortSingleton_","length","responseHandler_","shift","push","reqId","cb","opt_timeoutSeconds","req","timeoutSeconds","requestId","U2F_REGISTER_REQUEST"],"mappings":"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","file":"static/js/37.29f4c422.chunk.js","sourcesContent":["//@flow\n\nimport { sign, isSupported } from \"u2f-api\";\nimport Transport from \"@ledgerhq/hw-transport\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportError } from \"@ledgerhq/errors\";\n\nfunction wrapU2FTransportError(originalError, message, id) {\n  const err = new TransportError(message, id);\n  // $FlowFixMe\n  err.originalError = originalError;\n  return err;\n}\n\nfunction wrapApdu(apdu: Buffer, key: Buffer) {\n  const result = Buffer.alloc(apdu.length);\n  for (let i = 0; i < apdu.length; i++) {\n    result[i] = apdu[i] ^ key[i % key.length];\n  }\n  return result;\n}\n\n// Convert from normal to web-safe, strip trailing \"=\"s\nconst webSafe64 = (base64: string) =>\n  base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n\n// Convert from web-safe to normal, add trailing \"=\"s\nconst normal64 = (base64: string) =>\n  base64.replace(/-/g, \"+\").replace(/_/g, \"/\") +\n  \"==\".substring(0, (3 * base64.length) % 4);\n\nfunction attemptExchange(\n  apdu: Buffer,\n  timeoutMillis: number,\n  scrambleKey: Buffer,\n  unwrap: boolean\n): Promise<Buffer> {\n  const keyHandle = wrapApdu(apdu, scrambleKey);\n  const challenge = Buffer.from(\n    \"0000000000000000000000000000000000000000000000000000000000000000\",\n    \"hex\"\n  );\n  const signRequest = {\n    version: \"U2F_V2\",\n    keyHandle: webSafe64(keyHandle.toString(\"base64\")),\n    challenge: webSafe64(challenge.toString(\"base64\")),\n    appId: location.origin,\n  };\n  log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n  return sign(signRequest, timeoutMillis / 1000).then((response) => {\n    const { signatureData } = response;\n    if (typeof signatureData === \"string\") {\n      const data = Buffer.from(normal64(signatureData), \"base64\");\n      let result;\n      if (!unwrap) {\n        result = data;\n      } else {\n        result = data.slice(5);\n      }\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    } else {\n      throw response;\n    }\n  });\n}\n\nlet transportInstances = [];\n\nfunction emitDisconnect() {\n  transportInstances.forEach((t) => t.emit(\"disconnect\"));\n  transportInstances = [];\n}\n\nfunction isTimeoutU2FError(u2fError) {\n  return u2fError.metaData.code === 5;\n}\n\n/**\n * U2F web Transport implementation\n * @example\n * import TransportU2F from \"@ledgerhq/hw-transport-u2f\";\n * ...\n * TransportU2F.create().then(transport => ...)\n */\nexport default class TransportU2F extends Transport<null> {\n  static isSupported = isSupported;\n\n  /*\n   */\n  static list = (): * =>\n    // this transport is not discoverable but we are going to guess if it is here with isSupported()\n    isSupported().then((supported) => (supported ? [null] : []));\n\n  /*\n   */\n  static listen = (observer: *) => {\n    let unsubscribed = false;\n    isSupported().then((supported) => {\n      if (unsubscribed) return;\n      if (supported) {\n        observer.next({ type: \"add\", descriptor: null });\n        observer.complete();\n      } else {\n        observer.error(\n          new TransportError(\n            \"U2F browser support is needed for Ledger. \" +\n              \"Please use Chrome, Opera or Firefox with a U2F extension. \" +\n              \"Also make sure you're on an HTTPS connection\",\n            \"U2FNotSupported\"\n          )\n        );\n      }\n    });\n    return {\n      unsubscribe: () => {\n        unsubscribed = true;\n      },\n    };\n  };\n\n  scrambleKey: Buffer;\n\n  unwrap: boolean = true;\n\n  /**\n   * static function to create a new Transport from a connected Ledger device discoverable via U2F (browser support)\n   */\n  static async open(_: *, _openTimeout?: number = 5000): Promise<TransportU2F> {\n    return new TransportU2F();\n  }\n\n  constructor() {\n    super();\n    transportInstances.push(this);\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  async exchange(apdu: Buffer): Promise<Buffer> {\n    try {\n      return await attemptExchange(\n        apdu,\n        this.exchangeTimeout,\n        this.scrambleKey,\n        this.unwrap\n      );\n    } catch (e) {\n      const isU2FError = typeof e.metaData === \"object\";\n      if (isU2FError) {\n        if (isTimeoutU2FError(e)) {\n          emitDisconnect();\n        }\n        // the wrapping make error more usable and \"printable\" to the end user.\n        throw wrapU2FTransportError(\n          e,\n          \"Failed to sign with Ledger device: U2F \" + e.metaData.type,\n          \"U2F_\" + e.metaData.code\n        );\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /**\n   */\n  setScrambleKey(scrambleKey: string) {\n    this.scrambleKey = Buffer.from(scrambleKey, \"ascii\");\n  }\n\n  /**\n   */\n  setUnwrap(unwrap: boolean) {\n    this.unwrap = unwrap;\n  }\n\n  close(): Promise<void> {\n    // u2f have no way to clean things up\n    return Promise.resolve();\n  }\n}\n","'use strict';\nmodule.exports = require( './lib/u2f-api' );","'use strict';\n\nmodule.exports = API;\n\nvar chromeApi = require( './google-u2f-api' );\n\n// Feature detection (yes really)\nvar isBrowser = ( typeof navigator !== 'undefined' ) && !!navigator.userAgent;\nvar isSafari = isBrowser && navigator.userAgent.match( /Safari\\// )\n\t&& !navigator.userAgent.match( /Chrome\\// );\nvar isEDGE = isBrowser && navigator.userAgent.match( /Edge\\/1[2345]/ );\n\nvar _backend = null;\nfunction getBackend( Promise )\n{\n\tif ( !_backend )\n\t\t_backend = new Promise( function( resolve, reject )\n\t\t{\n\t\t\tfunction notSupported( )\n\t\t\t{\n\t\t\t\t// Note; {native: true} means *not* using Google's hack\n\t\t\t\tresolve( { u2f: null, native: true } );\n\t\t\t}\n\n\t\t\tif ( !isBrowser )\n\t\t\t\treturn notSupported( );\n\n\t\t\tif ( isSafari )\n\t\t\t\t// Safari doesn't support U2F, and the Safari-FIDO-U2F\n\t\t\t\t// extension lacks full support (Multi-facet apps), so we\n\t\t\t\t// block it until proper support.\n\t\t\t\treturn notSupported( );\n\n\t\t\tvar hasNativeSupport =\n\t\t\t\t( typeof window.u2f !== 'undefined' ) &&\n\t\t\t\t( typeof window.u2f.sign === 'function' );\n\n\t\t\tif ( hasNativeSupport )\n\t\t\t\tresolve( { u2f: window.u2f, native: true } );\n\n\t\t\tif ( isEDGE )\n\t\t\t\t// We don't want to check for Google's extension hack on EDGE\n\t\t\t\t// as it'll cause trouble (popups, etc)\n\t\t\t\treturn notSupported( );\n\n\t\t\tif ( location.protocol === 'http:' )\n\t\t\t\t// U2F isn't supported over http, only https\n\t\t\t\treturn notSupported( );\n\n\t\t\tif ( typeof MessageChannel === 'undefined' )\n\t\t\t\t// Unsupported browser, the chrome hack would throw\n\t\t\t\treturn notSupported( );\n\n\t\t\t// Test for google extension support\n\t\t\tchromeApi.isSupported( function( ok )\n\t\t\t{\n\t\t\t\tif ( ok )\n\t\t\t\t\tresolve( { u2f: chromeApi, native: false } );\n\t\t\t\telse\n\t\t\t\t\tnotSupported( );\n\t\t\t} );\n\t\t} );\n\n\treturn _backend;\n}\n\nfunction API( Promise )\n{\n\treturn {\n\t\tisSupported   : isSupported.bind( Promise ),\n\t\tensureSupport : ensureSupport.bind( Promise ),\n\t\tregister      : register.bind( Promise ),\n\t\tsign          : sign.bind( Promise ),\n\t\tErrorCodes    : API.ErrorCodes,\n\t\tErrorNames    : API.ErrorNames\n\t};\n}\n\nAPI.ErrorCodes = {\n\tCANCELLED: -1,\n\tOK: 0,\n\tOTHER_ERROR: 1,\n\tBAD_REQUEST: 2,\n\tCONFIGURATION_UNSUPPORTED: 3,\n\tDEVICE_INELIGIBLE: 4,\n\tTIMEOUT: 5\n};\nAPI.ErrorNames = {\n\t\"-1\": \"CANCELLED\",\n\t\"0\": \"OK\",\n\t\"1\": \"OTHER_ERROR\",\n\t\"2\": \"BAD_REQUEST\",\n\t\"3\": \"CONFIGURATION_UNSUPPORTED\",\n\t\"4\": \"DEVICE_INELIGIBLE\",\n\t\"5\": \"TIMEOUT\"\n};\n\nfunction makeError( msg, err )\n{\n\tvar code = err != null ? err.errorCode : 1; // Default to OTHER_ERROR\n\tvar type = API.ErrorNames[ '' + code ];\n\tvar error = new Error( msg );\n\terror.metaData = {\n\t\ttype: type,\n\t\tcode: code\n\t}\n\treturn error;\n}\n\nfunction deferPromise( Promise, promise )\n{\n\tvar ret = { };\n\tret.promise = new Promise( function( resolve, reject ) {\n\t\tret.resolve = resolve;\n\t\tret.reject = reject;\n\t\tpromise.then( resolve, reject );\n\t} );\n\t/**\n\t * Reject request promise and disconnect port if 'disconnect' flag is true\n\t * @param {string} msg\n\t * @param {boolean} disconnect\n\t */\n\tret.promise.cancel = function( msg, disconnect )\n\t{\n\t\tgetBackend( Promise )\n\t\t.then( function( backend )\n\t\t{\n\t\t\tif ( disconnect && !backend.native )\n\t\t\t\tbackend.u2f.disconnect( );\n\n\t\t\tret.reject( makeError( msg, { errorCode: -1 } ) );\n\t\t} );\n\t};\n\treturn ret;\n}\n\nfunction defer( Promise, fun )\n{\n\treturn deferPromise( Promise, new Promise( function( resolve, reject )\n\t{\n\t\ttry\n\t\t{\n\t\t\tfun && fun( resolve, reject );\n\t\t}\n\t\tcatch ( err )\n\t\t{\n\t\t\treject( err );\n\t\t}\n\t} ) );\n}\n\nfunction isSupported( )\n{\n\tvar Promise = this;\n\n\treturn getBackend( Promise )\n\t.then( function( backend )\n\t{\n\t\treturn !!backend.u2f;\n\t} );\n}\n\nfunction _ensureSupport( backend )\n{\n\tif ( !backend.u2f )\n\t{\n\t\tif ( location.protocol === 'http:' )\n\t\t\tthrow new Error( \"U2F isn't supported over http, only https\" );\n\t\tthrow new Error( \"U2F not supported\" );\n\t}\n}\n\nfunction ensureSupport( )\n{\n\tvar Promise = this;\n\n\treturn getBackend( Promise )\n\t.then( _ensureSupport );\n}\n\nfunction register( registerRequests, signRequests /* = null */, timeout )\n{\n\tvar Promise = this;\n\n\tif ( !Array.isArray( registerRequests ) )\n\t\tregisterRequests = [ registerRequests ];\n\n\tif ( typeof signRequests === 'number' && typeof timeout === 'undefined' )\n\t{\n\t\ttimeout = signRequests;\n\t\tsignRequests = null;\n\t}\n\n\tif ( !signRequests )\n\t\tsignRequests = [ ];\n\n\treturn deferPromise( Promise, getBackend( Promise )\n\t.then( function( backend )\n\t{\n\t\t_ensureSupport( backend );\n\n\t\tvar native = backend.native;\n\t\tvar u2f = backend.u2f;\n\n\t\treturn new Promise( function( resolve, reject )\n\t\t{\n\t\t\tfunction cbNative( response )\n\t\t\t{\n\t\t\t\tif ( response.errorCode )\n\t\t\t\t\treject( makeError( \"Registration failed\", response ) );\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdelete response.errorCode;\n\t\t\t\t\tresolve( response );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction cbChrome( err, response )\n\t\t\t{\n\t\t\t\tif ( err )\n\t\t\t\t\treject( err );\n\t\t\t\telse if ( response.errorCode )\n\t\t\t\t\treject( makeError( \"Registration failed\", response ) );\n\t\t\t\telse\n\t\t\t\t\tresolve( response );\n\t\t\t}\n\n\t\t\tif ( native )\n\t\t\t{\n\t\t\t\tvar appId = registerRequests[ 0 ].appId;\n\n\t\t\t\tu2f.register(\n\t\t\t\t\tappId, registerRequests, signRequests, cbNative, timeout );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tu2f.register(\n\t\t\t\t\tregisterRequests, signRequests, cbChrome, timeout );\n\t\t\t}\n\t\t} );\n\t} ) ).promise;\n}\n\nfunction sign( signRequests, timeout )\n{\n\tvar Promise = this;\n\n\tif ( !Array.isArray( signRequests ) )\n\t\tsignRequests = [ signRequests ];\n\n\treturn deferPromise( Promise, getBackend( Promise )\n\t.then( function( backend )\n\t{\n\t\t_ensureSupport( backend );\n\n\t\tvar native = backend.native;\n\t\tvar u2f = backend.u2f;\n\n\t\treturn new Promise( function( resolve, reject )\n\t\t{\n\t\t\tfunction cbNative( response )\n\t\t\t{\n\t\t\t\tif ( response.errorCode )\n\t\t\t\t\treject( makeError( \"Sign failed\", response ) );\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdelete response.errorCode;\n\t\t\t\t\tresolve( response );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction cbChrome( err, response )\n\t\t\t{\n\t\t\t\tif ( err )\n\t\t\t\t\treject( err );\n\t\t\t\telse if ( response.errorCode )\n\t\t\t\t\treject( makeError( \"Sign failed\", response ) );\n\t\t\t\telse\n\t\t\t\t\tresolve( response );\n\t\t\t}\n\n\t\t\tif ( native )\n\t\t\t{\n\t\t\t\tvar appId = signRequests[ 0 ].appId;\n\t\t\t\tvar challenge = signRequests[ 0 ].challenge;\n\n\t\t\t\tu2f.sign( appId, challenge, signRequests, cbNative, timeout );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tu2f.sign( signRequests, cbChrome, timeout );\n\t\t\t}\n\t\t} );\n\t} ) ).promise;\n}\n\nfunction makeDefault( func )\n{\n\tAPI[ func ] = function( )\n\t{\n\t\tif ( !global.Promise )\n\t\t\t// This is very unlikely to ever happen, since browsers\n\t\t\t// supporting U2F will most likely support Promises.\n\t\t\tthrow new Error( \"The platform doesn't natively support promises\" );\n\n\t\tvar args = [ ].slice.call( arguments );\n\t\treturn API( global.Promise )[ func ].apply( null, args );\n\t};\n}\n\n// Provide default functions using the built-in Promise if available.\nmakeDefault( 'isSupported' );\nmakeDefault( 'ensureSupport' );\nmakeDefault( 'register' );\nmakeDefault( 'sign' );\n","// Copyright 2014 Google Inc. All rights reserved\n//\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file or at\n// https://developers.google.com/open-source/licenses/bsd\n\n/**\n * @fileoverview The U2F api.\n */\n\n'use strict';\n\n/** Namespace for the U2F api.\n * @type {Object}\n */\nvar u2f = u2f || {};\n\nmodule.exports = u2f; // Adaptation for u2f-api package\n\n/**\n * The U2F extension id\n * @type {string}\n * @const\n */\nu2f.EXTENSION_ID = 'kmendfapggjehodndflmmgagdbamhnfd';\n\n/**\n * Message types for messsages to/from the extension\n * @const\n * @enum {string}\n */\nu2f.MessageTypes = {\n  'U2F_REGISTER_REQUEST': 'u2f_register_request',\n  'U2F_SIGN_REQUEST': 'u2f_sign_request',\n  'U2F_REGISTER_RESPONSE': 'u2f_register_response',\n  'U2F_SIGN_RESPONSE': 'u2f_sign_response'\n};\n\n/**\n * Response status codes\n * @const\n * @enum {number}\n */\nu2f.ErrorCodes = {\n  'OK': 0,\n  'OTHER_ERROR': 1,\n  'BAD_REQUEST': 2,\n  'CONFIGURATION_UNSUPPORTED': 3,\n  'DEVICE_INELIGIBLE': 4,\n  'TIMEOUT': 5\n};\n\n/**\n * A message type for registration requests\n * @typedef {{\n *   type: u2f.MessageTypes,\n *   signRequests: Array.<u2f.SignRequest>,\n *   registerRequests: ?Array.<u2f.RegisterRequest>,\n *   timeoutSeconds: ?number,\n *   requestId: ?number\n * }}\n */\nu2f.Request;\n\n/**\n * A message for registration responses\n * @typedef {{\n *   type: u2f.MessageTypes,\n *   responseData: (u2f.Error | u2f.RegisterResponse | u2f.SignResponse),\n *   requestId: ?number\n * }}\n */\nu2f.Response;\n\n/**\n * An error object for responses\n * @typedef {{\n *   errorCode: u2f.ErrorCodes,\n *   errorMessage: ?string\n * }}\n */\nu2f.Error;\n\n/**\n * Data object for a single sign request.\n * @typedef {{\n *   version: string,\n *   challenge: string,\n *   keyHandle: string,\n *   appId: string\n * }}\n */\nu2f.SignRequest;\n\n/**\n * Data object for a sign response.\n * @typedef {{\n *   keyHandle: string,\n *   signatureData: string,\n *   clientData: string\n * }}\n */\nu2f.SignResponse;\n\n/**\n * Data object for a registration request.\n * @typedef {{\n *   version: string,\n *   challenge: string,\n *   appId: string\n * }}\n */\nu2f.RegisterRequest;\n\n/**\n * Data object for a registration response.\n * @typedef {{\n *   registrationData: string,\n *   clientData: string\n * }}\n */\nu2f.RegisterResponse;\n\n\n// Low level MessagePort API support\n\n/**\n * Call MessagePort disconnect\n */\nu2f.disconnect = function() {\n  if (u2f.port_ && u2f.port_.port_) {\n    u2f.port_.port_.disconnect();\n    u2f.port_ = null;\n  }\n};\n\n/**\n * Sets up a MessagePort to the U2F extension using the\n * available mechanisms.\n * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback\n */\nu2f.getMessagePort = function(callback) {\n  if (typeof chrome != 'undefined' && chrome.runtime) {\n    // The actual message here does not matter, but we need to get a reply\n    // for the callback to run. Thus, send an empty signature request\n    // in order to get a failure response.\n    var msg = {\n      type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n      signRequests: []\n    };\n    chrome.runtime.sendMessage(u2f.EXTENSION_ID, msg, function() {\n      if (!chrome.runtime.lastError) {\n        // We are on a whitelisted origin and can talk directly\n        // with the extension.\n        u2f.getChromeRuntimePort_(callback);\n      } else {\n        // chrome.runtime was available, but we couldn't message\n        // the extension directly, use iframe\n        u2f.getIframePort_(callback);\n      }\n    });\n  } else {\n    // chrome.runtime was not available at all, which is normal\n    // when this origin doesn't have access to any extensions.\n    u2f.getIframePort_(callback);\n  }\n};\n\n/**\n * Connects directly to the extension via chrome.runtime.connect\n * @param {function(u2f.WrappedChromeRuntimePort_)} callback\n * @private\n */\nu2f.getChromeRuntimePort_ = function(callback) {\n  var port = chrome.runtime.connect(u2f.EXTENSION_ID,\n    {'includeTlsChannelId': true});\n  setTimeout(function() {\n    callback(null, new u2f.WrappedChromeRuntimePort_(port));\n  }, 0);\n};\n\n/**\n * A wrapper for chrome.runtime.Port that is compatible with MessagePort.\n * @param {Port} port\n * @constructor\n * @private\n */\nu2f.WrappedChromeRuntimePort_ = function(port) {\n  this.port_ = port;\n};\n\n/**\n * Posts a message on the underlying channel.\n * @param {Object} message\n */\nu2f.WrappedChromeRuntimePort_.prototype.postMessage = function(message) {\n  this.port_.postMessage(message);\n};\n\n/**\n * Emulates the HTML 5 addEventListener interface. Works only for the\n * onmessage event, which is hooked up to the chrome.runtime.Port.onMessage.\n * @param {string} eventName\n * @param {function({data: Object})} handler\n */\nu2f.WrappedChromeRuntimePort_.prototype.addEventListener =\n    function(eventName, handler) {\n  var name = eventName.toLowerCase();\n  if (name == 'message' || name == 'onmessage') {\n    this.port_.onMessage.addListener(function(message) {\n      // Emulate a minimal MessageEvent object\n      handler({'data': message});\n    });\n  } else {\n    console.error('WrappedChromeRuntimePort only supports onMessage');\n  }\n};\n\n/**\n * Sets up an embedded trampoline iframe, sourced from the extension.\n * @param {function(MessagePort)} callback\n * @private\n */\nu2f.getIframePort_ = function(callback) {\n  // Create the iframe\n  var iframeOrigin = 'chrome-extension://' + u2f.EXTENSION_ID;\n  var iframe = document.createElement('iframe');\n  iframe.src = iframeOrigin + '/u2f-comms.html';\n  iframe.setAttribute('style', 'display:none');\n  document.body.appendChild(iframe);\n\n  var hasCalledBack = false;\n\n  var channel = new MessageChannel();\n  var ready = function(message) {\n    if (message.data == 'ready') {\n      channel.port1.removeEventListener('message', ready);\n      if (!hasCalledBack)\n      {\n        hasCalledBack = true;\n        callback(null, channel.port1);\n      }\n    } else {\n      console.error('First event on iframe port was not \"ready\"');\n    }\n  };\n  channel.port1.addEventListener('message', ready);\n  channel.port1.start();\n\n  iframe.addEventListener('load', function() {\n    // Deliver the port to the iframe and initialize\n    iframe.contentWindow.postMessage('init', iframeOrigin, [channel.port2]);\n  });\n\n  // Give this 200ms to initialize, after that, we treat this method as failed\n  setTimeout(function() {\n    if (!hasCalledBack)\n    {\n      hasCalledBack = true;\n      callback(new Error(\"IFrame extension not supported\"));\n    }\n  }, 200);\n};\n\n\n// High-level JS API\n\n/**\n * Default extension response timeout in seconds.\n * @const\n */\nu2f.EXTENSION_TIMEOUT_SEC = 30;\n\n/**\n * A singleton instance for a MessagePort to the extension.\n * @type {MessagePort|u2f.WrappedChromeRuntimePort_}\n * @private\n */\nu2f.port_ = null;\n\n/**\n * Callbacks waiting for a port\n * @type {Array.<function((MessagePort|u2f.WrappedChromeRuntimePort_))>}\n * @private\n */\nu2f.waitingForPort_ = [];\n\n/**\n * A counter for requestIds.\n * @type {number}\n * @private\n */\nu2f.reqCounter_ = 0;\n\n/**\n * A map from requestIds to client callbacks\n * @type {Object.<number,(function((u2f.Error|u2f.RegisterResponse))\n *                       |function((u2f.Error|u2f.SignResponse)))>}\n * @private\n */\nu2f.callbackMap_ = {};\n\n/**\n * Creates or retrieves the MessagePort singleton to use.\n * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback\n * @private\n */\nu2f.getPortSingleton_ = function(callback) {\n  if (u2f.port_) {\n    callback(null, u2f.port_);\n  } else {\n    if (u2f.waitingForPort_.length == 0) {\n      u2f.getMessagePort(function(err, port) {\n        if (!err) {\n          u2f.port_ = port;\n          u2f.port_.addEventListener('message',\n            /** @type {function(Event)} */ (u2f.responseHandler_));\n        }\n\n        // Careful, here be async callbacks. Maybe.\n        while (u2f.waitingForPort_.length)\n          u2f.waitingForPort_.shift()(err, port);\n      });\n    }\n    u2f.waitingForPort_.push(callback);\n  }\n};\n\n/**\n * Handles response messages from the extension.\n * @param {MessageEvent.<u2f.Response>} message\n * @private\n */\nu2f.responseHandler_ = function(message) {\n  var response = message.data;\n  var reqId = response['requestId'];\n  if (!reqId || !u2f.callbackMap_[reqId]) {\n    console.error('Unknown or missing requestId in response.');\n    return;\n  }\n  var cb = u2f.callbackMap_[reqId];\n  delete u2f.callbackMap_[reqId];\n  cb(null, response['responseData']);\n};\n\n/**\n * Calls the callback with true or false as first and only argument\n * @param {Function} callback\n */\nu2f.isSupported = function(callback) {\n  u2f.getPortSingleton_(function(err, port) {\n    callback(!err);\n  });\n}\n\n/**\n * Dispatches an array of sign requests to available U2F tokens.\n * @param {Array.<u2f.SignRequest>} signRequests\n * @param {function((u2f.Error|u2f.SignResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\nu2f.sign = function(signRequests, callback, opt_timeoutSeconds) {\n  u2f.getPortSingleton_(function(err, port) {\n    if (err)\n      return callback(err);\n\n    var reqId = ++u2f.reqCounter_;\n    u2f.callbackMap_[reqId] = callback;\n    var req = {\n      type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n      signRequests: signRequests,\n      timeoutSeconds: (typeof opt_timeoutSeconds !== 'undefined' ?\n        opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC),\n      requestId: reqId\n    };\n    port.postMessage(req);\n  });\n};\n\n/**\n * Dispatches register requests to available U2F tokens. An array of sign\n * requests identifies already registered tokens.\n * @param {Array.<u2f.RegisterRequest>} registerRequests\n * @param {Array.<u2f.SignRequest>} signRequests\n * @param {function((u2f.Error|u2f.RegisterResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\nu2f.register = function(registerRequests, signRequests,\n    callback, opt_timeoutSeconds) {\n  u2f.getPortSingleton_(function(err, port) {\n    if (err)\n      return callback(err);\n\n    var reqId = ++u2f.reqCounter_;\n    u2f.callbackMap_[reqId] = callback;\n    var req = {\n      type: u2f.MessageTypes.U2F_REGISTER_REQUEST,\n      signRequests: signRequests,\n      registerRequests: registerRequests,\n      timeoutSeconds: (typeof opt_timeoutSeconds !== 'undefined' ?\n        opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC),\n      requestId: reqId\n    };\n    port.postMessage(req);\n  });\n};\n"],"sourceRoot":""}